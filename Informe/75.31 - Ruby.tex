\documentclass{article}

%% PAQUETES

% Paquetes generales
\usepackage[margin=2cm, paperwidth=210mm, paperheight=297mm]{geometry}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{gensymb}

% Paquetes para estilos
\usepackage{textcomp}
\usepackage{setspace}
\usepackage{colortbl}
\usepackage{color}
\usepackage{color}
\usepackage{upquote}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{caption}
\usepackage[T1]{fontenc}
\usepackage[scaled]{beramono}

% Paquetes extras
\usepackage{amssymb}
\usepackage{float}
\usepackage{graphicx}

%% Fin PAQUETES


% Definición de preferencias para la impresión de código fuente.
%% Colores
\definecolor{gray99}{gray}{.99}
\definecolor{gray95}{gray}{.95}
\definecolor{gray75}{gray}{.75}
\definecolor{gray50}{gray}{.50}
\definecolor{keywords_blue}{rgb}{0.13,0.13,1}
\definecolor{comments_green}{rgb}{0,0.5,0}
\definecolor{strings_red}{rgb}{0.9,0,0}

%% Caja de código
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFont{style_labelfont}{\color{black}\textbf}
\DeclareCaptionFont{style_textfont}{\it\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{gray95}{\parbox{16.78cm}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=style_labelfont,textfont=style_textfont}

\lstset{
	aboveskip = {1.5\baselineskip},
	backgroundcolor = \color{gray99},
	basicstyle = \ttfamily\footnotesize,
	breakatwhitespace = true,   
	breaklines = true,
	captionpos = t,
	columns = fixed,
	commentstyle = \color{comments_green},
	escapeinside = {\%*}{*)}, 
	extendedchars = true,
	frame = lines,
	keywordstyle = \color{keywords_blue}\bfseries,
	language = Ruby,                       
	numbers = left,
	numbersep = 5pt,
	numberstyle = \tiny\ttfamily\color{gray50},
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	rulecolor = \color{gray75},
	showspaces = false,
	showstringspaces = false, 
	showtabs = false,
	stepnumber = 1,
	stringstyle = \color{strings_red},                                    
	tabsize = 2,
	title = \null, % Default value: title=\lstname
	upquote = true,                  
}

%% FIGURAS
\captionsetup[figure]{labelfont=bf,textfont=it}
%% TABLAS
\captionsetup[table]{labelfont=bf,textfont=it}

% COMANDOS

%% Titulo de las cajas de código
\renewcommand{\lstlistingname}{Código}
%% Titulo de las figuras
\renewcommand{\figurename}{Figura}
%% Titulo de las tablas
\renewcommand{\tablename}{Tabla}
%% Referencia a los códigos
\newcommand{\refcode}[1]{\textit{Código \ref{#1}}}
%% Referencia a las imagenes
\newcommand{\refimage}[1]{\textit{Imagen \ref{#1}}}


\begin{document}

% Inserción del título, autores y fecha.
\title{\huge 75.31 Teoría de Lenguage \\ 
	  \Huge El lenguaje de programación Ruby \\
	  \bigskip \Large 28 de mayo de 2012 \\
	  \bigskip\bigskip \large\textit{Diaz, Federico (83568)\\Rossi, Federico Martín (92086)}}
\date{}
\maketitle




% INTRODUCCIÓN
\section{Introducción: \textit{Enfoque de la presentación}}

La presentación, como así también el presente informe, tienen como fin mostrar a los oyentes este veterano, y a la vez moderno lenguaje de programación desde un punto de vista diferente al que generalmente se acostumbra. Es nuestro objetivo el dar a conocer las fortalezas y debilidades de éste fijando la perspectiva de la presentación en las aplicaciones cotidiantas del lenguaje en el desarrollo de proyectos profesionales. Es decir, sin quitar importancia a tópicos importantes como la sintaxis, nos focalizaremos en detallar aquellas caracteristicas que hacen de Ruby un lenguaje interesante y ávido de nuevos conceptos.




% Un poco de historia
\section{Un poco de historia}

Ruby fue creado por \textit{Yukihiro ``Matz'' Matsumoto}. Matz comenzó a trabajar en Ruby en 1993, cuando tenia 28 años, mientras trabajaba para una empresa Open source (netlab.jp). Ya por ese entonces era muy conocido en Japón por tener un alto perfil de evangelista dentro de la comunidad Open source y por trabajar en varios productos Open source. Ruby es el primer software japones altamente conocido fuera de Japón, el cual fue presentado en 1995.

\begin{quotation}
\em``En 1993, yo estaba hablando con un colega acerca de lenguajes de scripting. Estaba muy impresionado por su poder y sus posibilidades. Sentía que el scripting era el camino a seguir.
	\par
	Me pareció que la programación orientada a objetos (POO) era muy adecuada para secuencias de comandos también (como viejo fan de la POO). Luego miré alrededor de la red. Me encontré con que Perl 5, que no se había lanzado todavía, implementaría las características de OO, pero  finalmente no resultó lo que esperába. Me di por vencido en creer en Perl como lenguaje de scripts orientado a objetos.
	\par
	Entonces me encontré con Python. Se trataba de un interprete y un lenguaje orientado a objetos. Pero no lo sentía como si fuera un "script" del lenguaje. Además, se trataba de un lenguaje híbrido de la programación de procedural y la programación orientada a objetos.
	\par
	Yo quería un lenguaje que fuera más poderoso que Perl, y más orientado a objetos que Python. Es por eso que me decidí a diseñar mi propio Lenguaje de programación''
\begin{flushright} Yukihiro Matsumoto (a.k.a. “Matz”)\end{flushright}
\end{quotation}  

Es así que comenzó a desarrollarlo el 24 de febrero de 1993 y en agosto desarrollo el primer Hello World con ruby. En 1994 se lanzó la primer versión alpha. Matz trabajó solo hasta el año 1996, momento en el cuál se formo la primer comunidad de Ruby.




% ¿QUE ES RUBY?
\section{¿Qué es Ruby?}

	Es un lenguaje escrito en C y fue diseñado teniendo en mente las capacidades de perl y phyton. [ Colocar contenido aquí ]




% EL LENGUAJE Y SUS PRINCIPIOS
\section{El lenguaje y sus Principios}
	
	Antes de iniciarnos en la sintaxis del lenguaje creemos necesario entender el por qué es que fue creado Ruby, es decir, entender el impacto que su creador deseaba que tuviera y las razones por las cuales conforma una forma muy particular de realizar aplicaciones.
	\par
	El lenguaje de programación Ruby es un ``\emph{lenguaje de programación interpretado para una rápida y fácil programación orientada a objetos}'' - Pero, ¿Qué significa esto? Veámos:
\bigskip\\

\textbf{Lenguaje de programación interpretado:}
\begin{itemize}
	\itemsep=1pt \topsep=0pt \partopsep=0pt \parskip=0pt \parsep=0pt
	\item habilidad para hacer llamadas directas al sistema operativo
	\item poderozo manejo y operaciones con cadenas y expresiones regulares
	\item respuestas inmediatas durante el desarrollo
\end{itemize}
\medskip

\textbf{Rápido y fácil:}
\begin{itemize}
\itemsep=2pt \topsep=0pt \partopsep=0pt \parskip=0pt \parsep=0pt
	\item innecesarias las declaraciones de variables
	\item variables no tipadas
	\item syntaxis simple y consistente
	\item el manejo de memoria es automático
\end{itemize}
\medskip

\textbf{Programación orientada a objetos:}
\begin{itemize}
\itemsep=2pt \topsep=0pt \partopsep=0pt \parskip=0pt \parsep=0pt
	\item todo es un objeto (como SmallTalk)
	\item clases, métodos, herencia, etc.
	\item métodos singleton (métodos que pertenecen a un sólo objeto)
	\item funcionalidad ``mixin'' por módulo
	\item iteradores y clausuras
\end{itemize}
\medskip

\textbf{Además:}
\begin{itemize}
\itemsep=2pt \topsep=0pt \partopsep=0pt \parskip=0pt \parsep=0pt
	\item números enteros de múltiple precisión
	\item procesamiento de excepciones
	\item carga dinámica
	\item soporte de concurrencia
\end{itemize}
\bigskip\bigskip

Sin duda, Ruby fue diseñado para hacer a los programadores mas productivos y felices. Esto es lo que el creador de Ruby nos dice:

\begin{quotation}
\em``Para mí, el propósito de la vida es, al menos en parte, tener alegría. Los programadores a menudo sienten alegría cuando se pueden concentrar en el aspecto creativo de la programación, por lo que Ruby está diseñado para que los programadores sean felices. Considero a un lenguaje de programación como una interfaz de usuario, por lo que deben seguir los principios de la interfaz de usuario.''

\begin{flushright} Yukihiro Matsumoto (a.k.a. “Matz”), 2000 \end{flushright}
\end{quotation}

\bigskip
¿Cuáles son los principios de una buena interfaz de usuario? Estos son los tres principios con citas de apoyo por parte de Matz:\\

\begin{quotation}
\noindent \textbf{Principio de concisión:} \textit{``Quiero que las computadoras sean mis siervos, no mis maestros. Por lo tanto, me gustaría darles órdenes rápidamente. Un buen siervo debe hacer un montón de trabajo con una breve orden.''}\\

\noindent \textbf{Principio de consistencia:} \textit{``... un pequeño conjunto de normas cubre la totalidad del lenguaje Ruby. Ruby es un lenguaje relativamente sencillo, pero no es demasiado simple. He tratado de seguir el principio de \textit{sin sorpresas}. Ruby no es demasiado único, por lo que un programador con conocimientos básicos de otros lenguajes de programación puede aprender muy rápidamente.''}\\

\noindent \textbf{Principio de flexibilidad:} \textit{``Porque las lenguas son para expresar el pensamiento, una lengua no debe restringir el pensamiento humano, sino que debe ayudarlo. Ruby consiste en un núcleo pequeño inmutable (es decir, sintaxis) y bibliotecas arbitrarias de clases extensibles...''}
\end{quotation}




% SINTAXIS
\section{Sintaxis}

	Ha llegado el momento de conocer la sintaxis de Ruby. El lector será capaz de notar una simpleza extrema de esta, lo que no significa una deficiencia en su potencial. Es decir, veremos que a partir de un número muy acotado de lineas de código seremos capaces de realizar programas realmente interesantes.

\subsection{Tipos}
Todos los tipos de ruby heredan de la clase Object, es decir que todos los tipos en ruby son objetos. Existen clases ya construidas que representan los tipos básicos de ruby sobre los cuales se construyen los bloques de todos los programas que se desarrollan en ruby.

\subsection{Tipos numéricos}
Los numeros en ruby son representados por las clases: \textit{Fixnum} (entero  -2¨30..2¨30) y \textit{Bignum}.
Cuando se crea un objeto numérico se asigna automáticamente al tipo Fixnum, si excede el rango será un Bignum.
Los numeros enteros son creados ingresando el número sin coma. El formato de representación particular depende de la base del sistema numérico que se utilice. Ruby soporta las bases numéricas 10, 8, 16 y 2.

% Código
\lstinputlisting[label=code:sintaxis_tipo_01,caption=``Tipos Numéricos'']{codes/sintaxis_tipo_01.rb} 
\bigskip

	En el \refcode{code:sintaxis_tipo_01}, se ven los tipos numércos básicos que encontramos en cualquier lenguaje. Debajo de estos se encuentran sus particulares al ser objetos y no ser simplemente "tipos nativos". Existen otras representaciones numéricas como los Numeros imaginarios (\textit{Complex}). En las secciones siguientes se verán el detalle el resto de los tipos básicos de ruby: \textit{Strings} y \textit{Collections}. 

\subsection{Strings}
Los \textit{strings} son simples secuencias de bytes que representan una secuencia de caracteres. A continuación se muestran ejemplos de código sobre sus cualidades básicas. En la siguiente sección se muestra el poder de las expresiones regulares.

% Código
\lstinputlisting[label=code:sintaxis_strings_01,caption=``Representacion de strings'']{codes/sintaxis_strings_01.rb}

% Código
\lstinputlisting[label=code:sintaxis_strings_02,caption=``Representación de strings'']{codes/sintaxis_strings_02.txt} 
\bigskip

% Código
\lstinputlisting[label=code:sintaxis_strings_03,caption=``Representacion de strings'']{codes/sintaxis_strings_03.txt} 
\bigskip

\subsection{Expresiones regulares}
Otro punto importante integrado en el lenguaje, y siguiendo los buenos resultados que se obtubieron en PERL, son las \textit{expresiones regulares}. Estas permiten comprobar si una cadena satisface un patrón en particular. En el \textbf{Cuadro 1} se puede observar un listado de los caracteres especiales para su uso.\\

\begin{table}[!hbt]
	\begin{center}
	\begin{tabular}{| l | l |}
		\hline
		\rowcolor[gray]{0.9}\textbf{Carácter} & \textbf{Descripción} \\
		\hline
		[] & Especificación de rango. (p.e. [a-z] representa una letra en el rango de la a a la z \\
		\hline
		\textbackslash w & Letra o dígito; es lo mismo que [0-9A-Za-z] \\
		\hline
		\textbackslash W & Ni letra, ni dígito. \\
		\hline
		\textbackslash s & Espacio, es lo mismo que [ t n r f] \\
		\hline
		\textbackslash S & No espacio \\
		\hline
		\textbackslash d & Dígito; es lo mismo que [0-9] \\
		\hline
		\textbackslash D & No dígito \\
		\hline
		\textbackslash b & Backspace (0x08) (sólo si aparece en una especificación de rango) \\
		\hline
		\textbackslash b & Límite de palabra (sólo si no aparece en una especificación de rango) \\
		\hline
		\textbackslash B & No límite de palabra \\
		\hline
		* & Cero o más repeticiones de lo que precede	\\
		\hline
		+ & Una o más repeticiones de lo que precede \\
		\hline
		[m,n] & Al menos m y como máximo n de lo que precede \\
		\hline
		? & Al menos una repetición de lo que precede; es lo mismo que [0,1]	\\
		\hline
		| & Puede coincidir con lo que precede o con lo que sigue \\
		\hline
		() & Agrupamiento \\
		\hline
	\end{tabular}
	\caption{Tabla de caracteres especiales en expresiones regulares}
	\end{center}

\end{table}


\noindent En el \refcode{code:sintaxis_regexpr_01} se puede observar un ejemplo de uso de las expresiones regulares.

% Código
\lstinputlisting[label=code:sintaxis_regexpr_01,caption=``Expresiones regulares'']{codes/sintaxis_regexp_01.rb} 
\bigskip

\subsection{Colecciones - Rangos}
La colección más primitiva de todas es el rango que permite representar una colección secuencial de valores (números o letras secuenciales)
Para indicar rangos se pueden utilizar los dos puntos (incluye al primer elemento y al último elemento inclusive) o tres puntos (excluye al último elemento del rango).

% Código
\lstinputlisting[label=code:sintaxis_rangos_01,caption=``Rangos'']{codes/sintaxis_rangos_01.rb} 
\bigskip


\subsection{Colecciones: \textit{Arrays}}
A continuación, en el código \refcode{code:sintaxis_arrays_01}, se muestran ejemplos sobre el uso de arrays. Más adelante, cuando se vean los conceptos de bloques se veran los iteradores sobre esta y el resto de las colecciones.

% Código
\lstinputlisting[label=code:sintaxis_arrays_01,caption=``Arrays'']{codes/sintaxis_arrays_01.rb} 
\bigskip

\subsection{Colecciones: \textit{Hash}}
Conocidos también como diccionarios (aunque en el mundo ruby se prefiere el nombre hash), a continuación se exponen ejemplos de uso de los mismos.

% Código
\lstinputlisting[label=code:sintaxis_hash_01,caption="Hash"]{codes/sintaxis_hash_01.rb} 
\bigskip

\subsection{Variables}
En ruby las variables son referencias a valores en memoria. Cuando se asigna una variable a otra, no se duplica el objeto. Para duplicar objetos se puede utilizar los métodos clone o dup que son de Object.
Las variables pueden tener alcance global, local (dadas por cualquier bloque: bloque de una estructura de control o bloque de un método) o de clase.

% Código
\lstinputlisting[label=code:sintaxis_variables_01,caption="Variables"]{codes/sintaxis_variables_01.rb} 
\bigskip

\subsection{Métodos}

Cuando un método es llamado en Ruby, técnicamente no se esta “llamando” a un método. Lo que se esta haciendo es enviando un mensaje a un objeto, como diciendo: “Hey, vos tenés este método?” si lo tiene entonces se ejecuta, si no lo tiene se lanza una exception “NoMethodError”. Esto, como se puede notar, proviene del paradigma de POO.
Los métodos siempre devuelven un valor, el que corresponde a la última sentencia que ejecuta. 

% Código
\lstinputlisting[label=code:sintaxis_metodos_01,caption="Declaración métodos"]{codes/sintaxis_metodos_01.txt} 

% Código
\lstinputlisting[label=code:sintaxis_metodos_02,caption="Parámetros"]{codes/sintaxis_metodos_02.txt} 

% Código
\lstinputlisting[label=code:sintaxis_metodos_03,caption=``Alto orden utilizando métodos'']{codes/sintaxis_metodos_03.txt} 

\subsection{Bloques y Func}

Los \textit{bloques} son un concepto muy poderoso e importante en Ruby. Estos son objetos que contienen código y todo el contexto necesario para ejecutarse.

% Código
\lstinputlisting[label=code:sintaxis_bloques&proc_01,caption=``Bloques básicos'']{codes/sintaxis_bloques&proc_01.txt} 
\bigskip

Un objeto procedimiento nuevo se obtiene utilizando la palabra reservada \textit{Proc}. Se pueden utilizar procedimientos anónimos. Estos objetos preservan el contexto en el cual fueron creados.

% Código
\lstinputlisting[label=code:sintaxis_bloques&proc_02,caption=``Ejemplo de uso de procedimientos'']{codes/sintaxis_bloques&proc_02.txt} 

% Código
\lstinputlisting[label=code:sintaxis_bloques&proc_03,caption=``Procedimientos anónimos'']{codes/sintaxis_bloques&proc_03.txt} 

% Código
\lstinputlisting[label=code:sintaxis_bloques&proc_04,caption=``Procedimientos y Bloques'']{codes/sintaxis_bloques&proc_04.txt} 

% Código
\lstinputlisting[label=code:sintaxis_bloques&proc_05,caption=``Función lambda'']{codes/sintaxis_bloques&proc_05.txt} 
\bigskip

\subsection{Estructuras de control}

% Código
\lstinputlisting[label=code:sintaxis_estructuracontrol_01,caption=``Estructuras de control'']{codes/sintaxis_estructuracontrol_01.rb}
\bigskip

\subsection{Convención de nombres}

En Ruby se añade, por convención, \textit{!} o \textit{?} al final de ciertos nombre de métodos.  La marca de exclamación (!, pronunciada como un “bang!” sonoro)  recalca algo potencialmente peligroso, es decir, algo que puede modificar el valor de lo que toca. El método de la clase cadena chop! afecta directamente a la cadena pero chop sin el signo de exclamación actúa sobre una copia.
Los nombres de métodos que finalizan con un signo de interrogación (?, pronunciada a veces como un “huh?” sonoro) indica que el método es un “predicado”, aquel que puede devolver o true o false.


\subsection{Métodos Singleton}

	El comportamiento de una instancia es determinado por su clase, pero hay momentos en los que es necesario que una instancia en particular posea un comportamiento especial. En la mayoría de los lenguajes deberíamos adentrarnos en la problematica de definir una nueva clase, la cual será instanciada una sola vez. En cambio, Ruby permite dar a cualquier objeto sus propios métodos.

% Código
\lstinputlisting[label=code:code1,caption=``Métodos Singleton ejecutado en la consola'']{codes/code1.consola} 
\bigskip

	En el \refcode{code:code1}, las instancias \textit{test1} y \textit{test2} pertenecen a la misma clase, pero en \textit{test2} se ha redefinido el método \textit{size} por lo que se comportará de forma diferente. Un método que pertenece sólo a un único objeto se denomina \textit{Método Singleton}.

%MULTITHREADING
\section{Multithreading}

	Los threads en ruby estan implementados completamente en el interprete de Ruby, esto lo hace portable puesto que no hay dependencia del sistema operativo, pero en contra parte con esto no se obtienen los beneficios de trabajar con threads nativos y por lo tanto se pueden experimentar problemas de innanición (starvation) al utilizar threads en Ruby, asi como en el caso en que se produsca un deadlock en los thread se podria suspender todo el proceso. Tambien en el caso en que un thread que esta en ejecución realiza una llamada a sistema que toma mucho tiempo, hasta que el interprete no tenga nuevamente el control no habria multithreading.
	\par
	En el \refcode{code:multithreading_01} se muestra como se utilizan threads para manejar cada transacción HTTP para descargar un conjunto de páginas.

% Código
\lstinputlisting[label=code:multithreading_01,caption=``Multithreading'']{codes/multithreading_01.rb} 
\bigskip

	Analizando las sutilezas que esconde el codigo podemos decir que los threads son creados haciendo la llamada \textit{Thread.new}. Esta recibe un bloque que contiene el código que sera ejecutado por el thread. En este caso el bloque utiliza la libreria \textit{net/http}.
	\par
	Cuando creamos un thread, estamos pasando la pagina web requerida como parametro. Luego este parametro es pasado dentro del bloque como myPage.

\subsection{Manipulando threads}

	En el código anterior vemos que un metodo que se invoca de cada thread es join. Cuando un programa en Ruby termina, se matan todos los threads sin tener en cuenta su estado. Join sirve para esperar que termine su ejecución un thread particular, de esta forma el codigo que vimos se asegura que terminen los 3 threads que se lanzaron.
	\par
	Además de join hay otros métodos, como por ejemplo \textit{Thread.current} obtiene el thread actual. Para obtener una lista de todos los threads en ejecución o parados se ejecuta Thread.list. Para saber el estado de un thread se puede ejecutar \textit{thread.status} o \textit{thread.alive}.


\subsection{Variables de threads}
Un thread puede acceder a cualquier variable que se encuentre en el alcance donde fue creado. Variables locales del thread (dentro del alcance del bloque de ejecucion del thread) no son compartidas por otros threads. Se puede utilizar a los thread como hash donde se puedan almacenar variables locales a cada thread y ser accedidas desde el el thread principal.

% Código
\lstinputlisting[label=code:multithreading_02,caption=``Variables de threads'']{codes/multithreading_02.txt} 
\bigskip

\subsection{Semáforos}

Para controlar el acceso a los recursos compartidos por varios thread (exclusión mutua), ruby implementa en el core los semaforos en la clase Mutex. En las imagenes siguientes se ven la sintaxis y posteriormente un ejemplo de uso.

% Código
\lstinputlisting[label=code:multithreading_03,caption=``Uso de mutex'']{codes/multithreading_03.txt} 
\bigskip

% Código
\lstinputlisting[label=code:multithreading_04,caption=``Ejemplo utilizando mutex'']{codes/multithreading_04.rb} 
\bigskip

% MANEJO DE MEMORIA
\section{Manejo de memoria}

	[ Colocar contenido aquí ]


% RECOLECCIÓN DE BASURA
\section{Recolección de basura}

	[ Colocar contenido aquí ]



% RECOLECCIÓN DE BASURA - El porvenir de Ruby 2.0: Bitmap Marking GC
\subsection{El porvenir de Ruby 2.0: \textit{Bitmap Marking GC}}

	[ Colocar contenido aquí ]




% RUBY ON RAILS: UN PUNTO FUERTE DEL LENGUAJE
\section{\textit{Ruby On Rails}: un punto fuerte del lenguaje}

En la actualidad, Ruby se ha popularizado en el mundo del desarrollo de las aplicaciones webs a través del framework \textit{Ruby On Rails}, o mas comúnmente conocido como \textit{Rails}, escrito en este mismo lenguaje.\par
Ruby on Rails nace como un framework de desarrollo web especialmente diseñado con un fin en particular: hacer la vida más fácil a las personas que desarrollan aplicaciones destinadas a la web. Muchas de estas personas quiza se sientan frustradas con tecnologias como PHP, Java o .NET, que si bien son buenas, conllevan problemas de carga de recursos y una complejidad innecesaria. Ruby on Rails es simplemente más sencillo.\par
 Rails utiliza el patrón MVC para poder administrar sus recursos. Si bien Java utiliza distintos frameworks también basados en MVC, Rails lleva el concepto mucho mas allá debido a que hay un lugar específico para cada parte del codigo, y cada componente de nuestra aplicación funciona de manera estándar. Es decir, es como si iniciaramos una aplicacion con el esqueleto previamente armado.\par
Todas estas potenciales caracteristicas hicieron que Ruby on Rails sea una de las razones por las que el lenguaje de programación Ruby haya logrado un importante impulso, siendo cada vez mas reconocido como una buena opción a la hora de elegir un lenguaje con el que llevar a cabo un proyecto.




% APLICACIONES
\section{Aplicaciones}

Con el paso del tiempo Ruby fue utilizado por un número cada vez mayor de desarrolladores para llevar a cabo proyectos de grande envergadura. A continuación se muestra un listado de aplicaciones\footnote{''Véase una lista mas completa de aplicaciones en los siguientes vínculos: http://rubyonrails.org/applications\\http://www.ruby-lang.org/en/documentation/success-stories''} realizadas en este lenguaje:
\bigskip\\

\textbf{Web:}
\begin{itemize}
	\itemsep=1pt \topsep=0pt \partopsep=0pt \parskip=0pt \parsep=0pt
	\item Twitter (http://www.twitter.com)
	\item Shopify (http://www.shopify.com)
	\item Groupon (http://www.groupon.com)
	\item XING (http://www.xing.com)
\end{itemize}
\medskip

\textbf{Simulaciones:}
\begin{itemize}
	\itemsep=1pt \topsep=0pt \partopsep=0pt \parskip=0pt \parsep=0pt
	\item \textit{NASA Langley Research Center} usa Ruby para llevar a cabo simulaciones. (http://www.larc.nasa.gov)
	\item Motorola (http://www.motorola.com)
\end{itemize}
\medskip

\textbf{Modelado 3D:}
\begin{itemize}
	\itemsep=1pt \topsep=0pt \partopsep=0pt \parskip=0pt \parsep=0pt
	\item Google SketchUp (http://sketchup.google.com)
\end{itemize}
\medskip

\textbf{Telecomunicaciones:}
\begin{itemize}
	\itemsep=1pt \topsep=0pt \partopsep=0pt \parskip=0pt \parsep=0pt
	\item \textit{Open Domain Server}: permitir a los usuarios el uso de DNS dinámicos (http://ods.org)
	\item \textit{Lucent}: uso en producto de telefonía wireless 3G (http://www.lucent.com)
\end{itemize}
\medskip




% UN EJEMPLO PRACTICO DE APLICACIÓN
\section{Un ejemplo práctico de aplicacion}





% CONCLUSIÓN
\section{Conclusión}




\end{document}
